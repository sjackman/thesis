---
title: "Introduction"
author: [Shaun D. Jackman]
bibliography: thesis.bib
csl: thesis.csl
rangeDelim: "&ndash;"
eqnPrefix: "Equation"
figPrefix: "Fig."
tblPrefix: ["Table", "Tables"]
---

Genome sequence assembly is an important open problem of bioinformatics. More contiguous genome assemblies expand the biological questions that may be answered from the assembly. To annotate a gene requires that the gene be assembled into a single scaffold. Comparison of gene synteny between species requires that adjacent genes be assembled into a single scaffold. These biological questions and many others are hampered by a fragmented assembly. Whole genome short read sequencing is a cost effective means of providing the bulk of the data for a genome sequencing project. An assembly of only short read sequencing however is confounded by repeats. Advances in sequencing technology provide long distance information that may be used to resolve repeats, but the data produced by these revolutionary technologies are often significantly different in nature than the technologies that came before. Existing algorithms and software must be adapted to benefit from these new sources of genomic information.

Two recent advances in sequencing technology are able to provide long-range genomic information: single-molecule sequencing [@Rusk_2009] and linked reads [@Eisenstein_2015]. Each technology has its own characteristic merits and challenges.

Single-molecule sequencing technologies yield long reads, which is their primary advantage. A secondary advantage of these technologies is that they do not rely on amplification, such as PCR, to construct the sequencing library, and so provide more uniform coverage of the genome. The biggest challenge to the analysis of these reads is the poor sequencing quality inherent in sequencing one single molecule of DNA. Whereas short-read sequencing produces reads that are over 99% accurate, or fewer than one error in a hundred bases, single-molecule sequencing produces reads that are less than 90% accurate, or more than one error in every ten bases. Designing algorithms that can analyse reads with such high error rates is the primary challenge posed by single-molecule sequencing.

Whereas paired-end sequencing produces two reads from each fragment of DNA, one from each end, the linked reads of 10X Genomics Chromium extends this concept to sequence multiple reads from each molecule of DNA. The primary benefit of linked reads is the large molecule size, with DNA molecules larger than 100 kbp [@Weisenfeld_2017]. A significant challenge is that each barcode contains multiple molecules of DNA, resulting in reads from disparate regions of the genome being present in a single barcode. When aligning to a reference genome, reads that align near each other can be grouped to infer which reads originate from the same molecule of DNA. When aligning to the contigs of a fragmented assembly, reads from the same barcode may be split across multiple contigs, but it is not evident whether those reads derived from the same molecule.

Assembling a genome using only single-molecule sequencing have provided genome assemblies that are more contiguous than assemblies using only short-read sequencing, as the long reads are better able to span repetitive sequences. Using only single-molecule sequencing has two limitations: the high error rate of the sequences imposes algorithmic and computational challenges, and single-molecule sequencing is currently more expensive than short-read sequencing.

A number of algorithms capable of assembling genomes using only single-molecule sequencing have been developed in recent years. The assemblers HGAP [@Chin_2013], Falcon [@Pendleton_2015; @Chin_2016], Canu [@Koren_2017], Miniasm [@Li_2016], Flye [@Kolmogorov_2018], and MARVEL [@Nowoshilow_2018] are capable of assembling genomes using only single-molecule sequencing. An axolotl salamander (*Ambystoma mexicanum*) genome at 32 Gbp is the largest assembled using only PacBio sequencing [@Nowoshilow_2018], and a human genome at 3 Gbp is the largest assembled using only Oxford Nanopore sequencing [@Jain_2018].

Short-read sequencing is currently more cost effective than long read sequencing. Large genome assembly projects constrained by cost continue to rely on short-read sequencing for the bulk of the sequencing depth. To achieve the contiguity desired of an assembly, additional genomic analysis methods must be used to provide the long-range genomic information. These methods include optical mapping [@Udall_2017], chromosome conformation capture [@Putnam_2016], and genetic maps [@Fierst_2015].

Genome sequence assembly is usually formulated as finding the correct paths through a sequence overlap graph. These paths represent the chromosomal sequences of the organism being sequenced. In long read assembly, a sequence overlap graph is constructed by an all-to-all comparison of the reads to themselves [@Myers_2000]. In short read assembly, the sequence overlap graph is a de Brujin graph, and the overlaps are of fixed-sized strings called *k*-mers [@Compeau_2011]. Exploring the graph to find these paths requires storing the entire graph in memory. That requirement is not onerous for bacterial and small eukaryote genome projects. For larger genomes, it can pose a significant challenge. ABySS was the first genome assembly tool to assemble a human genome from short read sequencing [@Simpson_2009]. At that time, no readily available computer had enough memory to fit the entire graph in memory. The problem was surmounted by using multiple computers connected by a high-speed network to aggregate sufficient memory to store the graph. The speed of communication over the network now became the limiting factor. Chapter 2 presents ABySS 2.0 [@Jackman_2017], which reduces the memory requirements of assembly by ten fold over ABySS 1.0. It does so by using a probabilistic data structure called a Bloom filter [@Bloom_1970] to represent the de Bruijn graph. This technique was first introduced by Minia [@Chikhi_2013]. Minia does not however make use of paired-end reads, limiting the contiguity of its assemblies. Incorporating this strategy into ABySS resulted in a more contiguous genome assembly than Minia, while reducing the memory requirements of ABySS substantially.

Genome scaffolding is the problem of ordering and orienting assembled contigs. ABySS includes the ability to scaffold genomes using paired-end and mate-pair reads. Two other tools for this purpose are SSPACE [@Boetzer_2010] and BESST [@Sahlin_2014]. HiRise [@Putnam_2016] uses chromosome conformation capture to scaffold a genome, hybridScaffold uses optical mapping [@Udall_2017], and ARCS [@Yeo_2017] uses linked reads. Most scaffolding tools assume that the contigs given as input are correct. When assembled contigs contain errors, those errors both limit the contiguity of the assembly, and confound downstream analyses, such as annotating genes and comparative genomics. Chapter 3 presents Tigmint [@Jackman_2018], which uses linked reads to identify and correct assembly errors. Correcting misassemblies before scaffolding yield a final assembly that is both more contiguous and more correct than scaffolding without correction.

Genome assembly is only a stopping point on the way to downstream analyses, one of which is annotating the genes of the genome. Scientific discovery is however rarely a linear path. A genome sequencing project may iterate a few times between genome assembly and genome annotation, as new sequencing data is generated. Genes with unknown function are commonly assigned a simple serial number identifier. When a newly assembled version of the genome is annotated, the order of the genes on the scaffolds will change as the scaffolds are rearranged. The gene identifiers, when assigned serially, will have no resemblance to those of previous versions of the assembly. This complete upheaval is rather inconvenient for the scientists relying on these annotations. The order of genes may change between assembly versions, but the coding sequence of most genes will remain unchanged. Chapter 4 presents UniqTag [@Jackman_2015_UniqTag], a system that assigns unique identifiers to genes based on their coding sequence, so that genes with unchanged coding sequence will have consistent and stable identifiers between assembly versions.

Using a bioinformatics tool naturally requires first installing that tool. Installing commercial software is usually straight forward. Installing bioinformatics software is often not. Installing dependencies of the tool, as well as the dependencies of dependencies, can consume days of effort, or may fail altogether. Package managers like Bioconda [@Gr_ning_2018] and Linuxbrew [@Jackman_2016] make installing software and their dependencies much easier.Conflicting requirements between dependencies of different tools can still cause trouble. Container environments like Docker (<https://docker.com>) and Singularity [@Kurtzer_2017] provide the tool and all of its dependencies in a single image. BioContainers [@Leprevost_2017] provides a docker image for each tool found in Bioconda. Most bioinformatics analyses require more than one tool, and Docker images are not easily combined. A seasoned bioinformatician may use a workflow management tool such as Nextflow [@Di_Tommaso_2017] or Common Workflow Language [@Amstutz_2016] to orchestrate an analysis using multiple containers. A simpler solution is needed in an educational environment where workflow management has not yet been taught. Chapter 5 presents ORCA, a comprehensive bioinformatics environment that provides all the bioinformatics tools available to the Homebrew/Linuxbrew package manager in a single Docker image.

The organellar genomes of plants have a few noteworthy features. Mitochondria and chloroplasts are responsible for two key cellular functions: synthesizing ATP and photosynthesis. Cytoplasmic male sterility is exploited in the commercial production of hybrid seed, and it is associated with abnormalities in the mitochondrial genome [@Schnable_1998]. Organellar genomes are useful for phylogenetic studies due to their uniparental inheritance [@Birky_1995]. Sequencing organellar genomes is possible on a modest budget, due to their small genome size, compared to the nuclear genome.
Over 3,000 plastid genomes are available from NCBI RefSeq. Mitochondrial genomes are less well represented, but nonetheless, over two hundred plant mitochondrial genomes are available. Gymnosperm mitochondrial genomes are however quite poorly represented, with a mere four mitochondrial genomes in RefSeq [@Chaw_2008; @Guo_2016]. Chapter 6 presents the draft mitochondrial genome of white spruce (*Picea glauca*), assembled from short reads, as well as the complete plastid genome [@Jackman_2015]. Chapter 7 presents the complete mitochondrial genome of Sitka spruce (*Picea sitchensis*), assembled from long reads. It is the largest complete mitochondrial genome of a gymnosperm.

The assembly of conifer genomes is difficult due to their large size. Six conifer genomes have been assembled, all 20 Gbp and larger: Norway spruce (*Picea abies*) [@Nystedt_2013], interior white spruce (*Picea glauca*) [@Birol_2013], white spruce [@Warren_2015_Improved], loblolly pine (*Pinus taeda*) [@Zimin_2014; @Zimin_2017], sugar pine (*Pinus lambertiana*) [@Stevens_2016] and Douglas fir (*Pseudotsuga menziesii*) [@Neale_2017]. Few assemblers are capable of assembling genomes of this size. The Norway spruce genome used a hierarchical sequencing strategy, combining fosmid pools and whole genome short-read sequencing [@Nystedt_2013]. It was assembled using commercial software from CLC bio (<http://clcbio.com>). The loblolly pine genome was assembled from a combination of short and long reads using MaSuRCA [@Zimin_2013; @Zimin_2017_MaSuRCA]. The white spruce genome was assembled from paired-end and mate-pair reads using ABySS 1.0 [@Simpson_2009]. The sugar pine and Douglas fir genomes were assembled from paired-end and mate-pair reads using MaSuRCA and SOAPdenovo2 [@Luo_2012]. Chapter 8 presents the assembly of the 12 Gbp western redcedar (*Thuja plicata*) genome, assembled from paired-end, mate-pair, and linked reads using ABySS 2.0 [@Jackman_2017], Tigmint [@Jackman_2018], and ARCS [@Yeo_2017], and it demonstrates the effectiveness of these tools in assembling large genomes from short and linked reads.

# References
