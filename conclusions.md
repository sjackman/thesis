---
title: "Conclusions"
author: [Shaun D. Jackman]
bibliography: thesis.bib
csl: thesis.csl
rangeDelim: "&ndash;"
eqnPrefix: "Equation"
figPrefix: "Fig."
tblPrefix: ["Table", "Tables"]
---

# Recommendations

Previously, each variant calling tool was tightly coupled to an associated read alignment tool. The creation of the SAM/BAM file format to store read alignments allowed any read aligner to be used with any variant caller, provided they both used this common SAM/BAM file format. This development led to an efficiency in the development of variant calling tools, which no longer had to address the now separate problem of read alignment. Genome sequence assembly however remains a fragmented space of tools specialized for each sequencing data type (short reads, linked reads, or long reads), size of genome, and other genome characteristics, such as ploidy. Effective tools exist that address a particular genome size and a combination of data types. Unicycler [@Wick_2017_Unicycler] assembles bacterial-sized genomes using a combination of short and long reads. Supernova [@Weisenfeld_2017] assembles mammalian-sized genomes genomes using exclusively linked reads. Canu [@Koren_2017] assembles mammalian-sized genomes using exclusively long reads. ABySS [@Jackman_2017] assembles conifer-sized genomes using a mixture of short reads and linked reads. Behind the curtain, assembly tools are typically composed of a pipeline of individual but tightly coupled components. Sharing components between tools is unfortunately rather difficult, due in part to a lack of a common format to exchange data. For this reason, genome assembly tools abound, each that addresses a particular niche of sequencing type and genome size.

Sequence graphs are central to genome assembly. Intermediate stages of assembly often employ an overlap graph of reads (typical for long read assembly) or *k*-mers (typical for short read assembly). The final assembly is represented as a graph of overlapping or adjacent assembled contigs. A common file format has recently been created to represent these assembly graphs, Graphical Fragment Assembly (GFA; <https://github.com/GFA-spec/GFA-spec/>). Numerous tools have adopted GFA as the common format to represent an assembly graph. Assembly tools produce assembly graphs in GFA format, such as ABySS [@Jackman_2017], Bcalm2 [@Chikhi_2016], Canu [@Koren_2017], Miniasm [@Li_2016], SPAdes [@Bankevich_2012], and Unicycler [@Wick_2017_Unicycler]. Visualization tools render assembly graphs in GFA format, such as Bandage [@Wick_2015], GfaViz [@Gonnella_2018], and Assembly Graph Browser (<https://github.com/almiheenko/AGB>). An exciting opportunity now presents itself to decompose monolithic assembly pipelines into individual components, using GFA as the exchange format, so that novel assembly pipelines may be composed from a toolbox of existing components. The Overlap, Layout, Consensus (OLC) paradigm, typically employed for long read assembly, is well suited to this aim. Whereas a comprehensive pipeline like Canu addresses all three stages, a pipeline like Minimap2, Miniasm, and Racon is modular. The advantage in modularity is that a new tool can be created to improve on one of these components without needing to recreate the entire assembly pipeline from scratch.

Modular assembler components would enable hybrid assemblies of multiple sequencing technologies, by combining multiple assembler components, each of which would analyse the data of a particular sequencing technology to improve the assembly. Under the hood, Unicycler works in this fashion, assembling a de Bruijn graph from short reads, resolving repeats in the graph using long reads, and finally polishing the assembled sequence using the short reads once again. Unicycler's biggest limitation is that it does not scale to large genomes. With modular assembler components, a similar pipeline could be composed to address large genome assembly using, for example, ABySS 2.0 to assemble the de Bruijn graph, Minimap2 to align the long reads to the assembly, a needed but currently absent tool to resolve repeats using aligned long reads, EMA [@Shajii_2017] to align linked reads, and finally Tigmint [@Jackman_2018] and Pilon [@Walker_2014] to correct assembly errors and polish the assembly using linked reads.

High-quality assembly of large genomes requires employing a sequencing strategy that makes use of multiple sequencing technologies. Each technology has its unique strength and weaknesses, and the strengths of one technology compensates for the weaknesses of another. Modern sequencing projects employ multiple sequencing technologies. Modern assembly tools need to interoperate to effectively employ this wonderful variety of DNA sequencing technologies.

# References
